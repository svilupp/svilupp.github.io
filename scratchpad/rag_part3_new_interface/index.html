<!doctype html> <html lang=en > <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src= 'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f); })(window,document,'script','dataLayer','GTM-M28VNQP');</script> <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/styles/github.min.css"> <link href="/css/franklin.css" rel=stylesheet > <link href="/css/vela.css" rel=stylesheet > <script src="/libs/vela/jquery.min.js"></script> <link rel=icon  href="/assets/favicon.png"> <title>Jan's Scratchpad</title> <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-M28VNQP" height=0  width=0  style="display:none;visibility:hidden"></iframe></noscript> <div class="main-nav slideout-menu slideout-menu-left" id=menu > <div class=flex-container > <span class=sidebar-brand > <h3 style='font-size: 25px'>Scratchpad</h3> </span> </div> <nav class=sidebar-nav > <ul class=metismenu  id=metismenu  > <li><a href="/index.html">Home</a> <li><a href="/scratchpad/">Posts</a> <li><a href="/about/">About</a> <li><a href="/tag/">Tags</a> <li><a href="/privacy_policy/">Privacy Policy</a> <li><a href="/cookie_policy/">Cookie Policy</a> </ul> </nav> </div> <main id=panel  class="slidout-panel slideout-panel-left"> <div class="toggle-button hamburger hamburger--spin"> <div class=hamburger-box > <div class=hamburger-inner ></div> </div> </div> <h1 class="page title">Empowering AI with Knowledge: The New RAG Interface in PromptingTools</h1> <hr> <div class=franklin-content ><h1 id=tldr ><a href="#tldr" class=header-anchor >TL;DR</a></h1> <p>The new RAGTools module in the PromptingTools.jl package introduces enhanced modularity and straightforward extension capabilities, enabling developers and researchers to easily customize and build Retrieval-Augmented Generation &#40;RAG&#41; systems tailored to their specific needs in Julia.</p> <div class=franklin-toc ><ol><li><a href="#introduction">Introduction</a><li><a href="#ragtools_module_a_primer">RAGTools Module: A Primer</a><li><a href="#unveiling_new_functionalities">Unveiling New Functionalities</a><ol><li><a href="#answer_annotation_example">Answer Annotation Example</a></ol><li><a href="#a_closer_look_at_the_modular_interface">A Closer Look at the Modular Interface</a><li><a href="#rag_pipeline_workflow">RAG Pipeline Workflow</a><ol><li><a href="#preparation_phase">Preparation Phase</a><li><a href="#retrieval_phase">Retrieval Phase</a><li><a href="#generation_phase">Generation Phase</a><li><a href="#where_to_start_quick_experiment_or_customize">Where to Start: Quick, Experiment, or Customize</a><li><a href="#how_to_customize_the_pipeline">How to Customize the Pipeline</a><li><a href="#passing_keyword_arguments_to_customize_the_pipeline">Passing Keyword Arguments to Customize the Pipeline</a><li><a href="#using_custom_indexes_or_vector_databases">Using Custom Indexes or Vector Databases</a></ol><li><a href="#conclusion">Conclusion</a><li><a href="#we_want_to_hear_from_you">We Want to Hear from You&#33;</a></ol></div> <h2 id=introduction ><a href="#introduction" class=header-anchor >Introduction</a></h2> <p>The introduction of Retrieval-Augmented Generation &#40;RAG&#41; systems addresses key challenges in generative AI, notably the tendency to lack crucial information and produce hallucinated content. By integrating external knowledge, RAG systems significantly enhance the accuracy and reliability of AI-generated responses. </p> <p>The <code>RAGTools</code> module within the PromptingTools.jl package enables the creation of such systems, offering a path to mitigate these issues. As this module matures, plans are in place to transition it into its own dedicated package, further facilitating the development and adoption of RAG systems.</p> <h2 id=ragtools_module_a_primer ><a href="#ragtools_module_a_primer" class=header-anchor >RAGTools Module: A Primer</a></h2> <p><code>RAGTools</code> offers an experimental but formidable suite of utilities designed to facilitate the crafting of RAG applications with minimal fuss. Central to its arsenal is the <code>airag</code> function, a master orchestrator that seamlessly combines AI insights with user-curated knowledge, unlocking new dimensions of accuracy and relevance in answers.</p> <p>You can get started very quickly:</p> <pre><code class="julia hljs"><span class=hljs-comment ># required dependencies to load the necessary extensions</span>
<span class=hljs-keyword >using</span> LinearAlgebra, SparseArrays 
<span class=hljs-keyword >using</span> PromptingTools
<span class=hljs-keyword >using</span> PromptingTools.Experimental.RAGTools
<span class=hljs-comment ># to access unexported functionality</span>
<span class=hljs-keyword >const</span> RT = PromptingTools.Experimental.RAGTools

<span class=hljs-comment >## Sample data</span>
sentences = [
    <span class=hljs-string >&quot;Search for the latest advancements in quantum computing using Julia language.&quot;</span>,
    <span class=hljs-string >&quot;How to implement machine learning algorithms in Julia with examples.&quot;</span>,
    <span class=hljs-string >&quot;Looking for performance comparison between Julia, Python, and R for data analysis.&quot;</span>,
    <span class=hljs-string >&quot;Find Julia language tutorials focusing on high-performance scientific computing.&quot;</span>,
    <span class=hljs-string >&quot;Search for the top Julia language packages for data visualization and their documentation.&quot;</span>,
    <span class=hljs-string >&quot;How to set up a Julia development environment on Windows 10.&quot;</span>,
    <span class=hljs-string >&quot;Discover the best practices for parallel computing in Julia.&quot;</span>,
    <span class=hljs-string >&quot;Search for case studies of large-scale data processing using Julia.&quot;</span>,
    <span class=hljs-string >&quot;Find comprehensive resources for mastering metaprogramming in Julia.&quot;</span>,
    <span class=hljs-string >&quot;Looking for articles on the advantages of using Julia for statistical modeling.&quot;</span>,
    <span class=hljs-string >&quot;How to contribute to the Julia open-source community: A step-by-step guide.&quot;</span>,
    <span class=hljs-string >&quot;Find the comparison of numerical accuracy between Julia and MATLAB.&quot;</span>,
    <span class=hljs-string >&quot;Looking for the latest Julia language updates and their impact on AI research.&quot;</span>,
    <span class=hljs-string >&quot;How to efficiently handle big data with Julia: Techniques and libraries.&quot;</span>,
    <span class=hljs-string >&quot;Discover how Julia integrates with other programming languages and tools.&quot;</span>,
    <span class=hljs-string >&quot;Search for Julia-based frameworks for developing web applications.&quot;</span>,
    <span class=hljs-string >&quot;Find tutorials on creating interactive dashboards with Julia.&quot;</span>,
    <span class=hljs-string >&quot;How to use Julia for natural language processing and text analysis.&quot;</span>,
    <span class=hljs-string >&quot;Discover the role of Julia in the future of computational finance and econometrics.&quot;</span>
]
sources = map(i -&gt; <span class=hljs-string >&quot;Doc<span class=hljs-variable >$i</span>&quot;</span>, <span class=hljs-number >1</span>:length(sentences))

<span class=hljs-comment >## Build the index</span>
index = build_index(sentences; chunker_kwargs=(; sources))

<span class=hljs-comment >## Generate an answer</span>
question = <span class=hljs-string >&quot;What are the best practices for parallel computing in Julia?&quot;</span>

msg = airag(index; question) <span class=hljs-comment ># short for airag(RAGConfig(), index; question)</span>
<span class=hljs-comment >## Output:</span>
<span class=hljs-comment >## [ Info: Done with RAG. Total cost: \$0.0</span>
<span class=hljs-comment >## AIMessage(&quot;Some best practices for parallel computing in Julia include us...</span></code></pre> <h2 id=unveiling_new_functionalities ><a href="#unveiling_new_functionalities" class=header-anchor >Unveiling New Functionalities</a></h2> <p>The latest update to the <code>RAGTools</code> module introduces key features that enhance the creation and analysis of RAG systems:</p> <ul> <li><p><strong>Modular Interface</strong>: The RAG pipeline is now broken down into distinct components &#40;see details below&#41;, allowing users to customize and extend each phase with ease. Simply define a new type and method for only the components you wish to modify.</p> <li><p><strong>Pipeline Transparency</strong>: Users can now view detailed background information on the RAG pipeline, including the sources selected and the process at each stage &#40;use <code>return_all&#61;true</code>&#41;.</p> <li><p><strong>Advanced RAG Functionality</strong>: Default pipeline configuration now comes with question rephrasing, reranking results, and two-step answer refinement. There is even a <code>postprocess</code> placeholder, so you can add some logging or other transformations. You can easily switch between different implementations thanks to Julia&#39;s method dispatch while calling the same top-level function.</p> <li><p><strong>Answer Annotation</strong>: The final answers can be annotated with hallucination scores, showing the overlap with source materials and indicating the origin of specific information within the answer.</p> </ul> <h3 id=answer_annotation_example ><a href="#answer_annotation_example" class=header-anchor >Answer Annotation Example</a></h3> <p>With a small change, you can see which sources were used for each sentence in the answer &#40;<code>&#91;1&#93;</code>&#41;, how strongly they were supported &#40;<code>&#91;..,0.9&#93;</code>&#41;, and the color highlight of the &quot;unknown&quot; words &#40;with magenta color&#41;:</p> <pre><code class="julia hljs">result = airag(index; question, return_all = <span class=hljs-literal >true</span>)
pprint(result)</code></pre> <p><img src="/assets/rag_part3_new_interface/annotated_answer.png" alt="Answer Annotation" /></p> <p>You immediately see that while a lot of the package names and macros look sensible, they did NOT come from our trusted knowledge base &#40;all highlighted in magenta&#41;. In real life, we would also have clearly labeled source links that we could verify with one click.</p> <p>The annotation system is fully customizable &#40;bring your own logic, styles, etc.&#41;. You can also obtain this information in HTML format to easily show it in your Genie apps&#33;</p> <h2 id=a_closer_look_at_the_modular_interface ><a href="#a_closer_look_at_the_modular_interface" class=header-anchor >A Closer Look at the Modular Interface</a></h2> <p>At the heart of the new <code>RAGTools</code> interface is its modular design, encouraging the interchange of pipeline components. This approach allows for extensive customization at every stage, from data preparation to answer generation, ensuring that developers can easily adapt the system to meet their specific needs.</p> <p>This system is designed for information retrieval and response generation, structured in three main phases:</p> <ul> <li><p><strong>Preparation</strong>, when you create an instance of <code>AbstractIndex</code></p> <li><p><strong>Retrieval</strong>, when you surface the top most relevant chunks/items in the index and return <code>AbstractRAGResult</code>, which contains the references to the chunks &#40;<code>AbstractCandidateChunks</code>&#41;</p> <li><p><strong>Generation</strong>, when you generate an answer based on the context built from the retrieved chunks, return either <code>AIMessage</code> or <code>AbstractRAGResult</code></p> </ul> <p>The associated methods are: </p> <ul> <li><p><strong><code>build_index</code></strong>: Indexes relevant documents for retrieval.</p> <li><p><strong><code>retrieve</code></strong>: Selects pertinent information chunks based on the query.</p> <li><p><strong><code>generate&#33;</code></strong>: Produces the final answer using the retrieved data.</p> </ul> <p><code>airag</code> is simply a wrapper around <code>retrieve</code> and <code>generate&#33;</code>, providing a convenient way to execute the entire RAG pipeline in one go.</p> <p><img src="/assets/rag_part3_new_interface/rag_diagram_highlevel.png" alt="High-level Diagram" /></p> <p>Note that the first argument is always the main dispatching parameter that you can use to customize the behavior of the pipeline. This design ensures that users can easily swap out components or extend the system without disrupting the overall functionality.</p> <h2 id=rag_pipeline_workflow ><a href="#rag_pipeline_workflow" class=header-anchor >RAG Pipeline Workflow</a></h2> <p>The RAG pipeline is structured into distinct stages, each comprising several critical sub-steps to ensure the generation of accurate and relevant answers.</p> <p>If you want to change the behavior of any step, you can define a new type and method for that step.</p> <p>All customization are subtypes of the abstract types, so use <code>subtypes</code> function to discover the currently available implementations, eg, <code>subtypes&#40;AbstractReranker&#41;</code>.</p> <h3 id=preparation_phase ><a href="#preparation_phase" class=header-anchor >Preparation Phase</a></h3> <ul> <li><p><strong><code>build_index</code></strong>:</p> <ul> <li><p><code>get_chunks</code>: Segments documents into manageable chunks.</p> <li><p><code>get_embeddings</code>: Generates embeddings for similarity searches.</p> <li><p><code>get_tags</code>: Tags chunks for efficient filtering.</p> </ul> </ul> <h3 id=retrieval_phase ><a href="#retrieval_phase" class=header-anchor >Retrieval Phase</a></h3> <ul> <li><p><strong><code>retrieve</code></strong>:</p> <ul> <li><p><code>rephrase</code>: Optionally rephrases queries for better matching.</p> <li><p><code>find_closest</code>: Identifies the most relevant document chunks.</p> <li><p><code>find_tags</code>: Filters chunks based on specific tags.</p> <li><p><code>rerank</code>: Reranks chunks to prioritize the best matches.</p> </ul> </ul> <h3 id=generation_phase ><a href="#generation_phase" class=header-anchor >Generation Phase</a></h3> <ul> <li><p><strong><code>generate&#33;</code></strong>:</p> <ul> <li><p><code>build_context&#33;</code>: Constructs the context from selected chunks for the answer.</p> <li><p><code>answer&#33;</code>: Generates a preliminary answer.</p> <li><p><code>refine&#33;</code>: Refines the answer for clarity and relevance.</p> <li><p><code>postprocess&#33;</code>: Applies final touches to prepare the response.</p> </ul> </ul> <p>A visual summary with the corresponding types:</p> <p><img src="/assets/rag_part3_new_interface/rag_diagram_detailed.png" alt="Cheater-7b Performance" /></p> <h3 id=where_to_start_quick_experiment_or_customize ><a href="#where_to_start_quick_experiment_or_customize" class=header-anchor >Where to Start: Quick, Experiment, or Customize</a></h3> <p>To operate the RAG system:</p> <ul> <li><p><strong>Quick Start</strong>: Utilize <code>airag</code> for an immediate, out-of-the-box solution, suitable for rapid testing.</p> <li><p><strong>Experimentation</strong>: Leverage <code>RAGConfig</code> to try out different implementations of <code>airag</code>, tweaking the system for better performance.</p> <li><p><strong>Customization</strong>: Dive into <code>retrieve</code> and <code>generate&#33;</code> for detailed customization, tailoring the process to your precise requirements.</p> </ul> <h3 id=how_to_customize_the_pipeline ><a href="#how_to_customize_the_pipeline" class=header-anchor >How to Customize the Pipeline</a></h3> <p>If you want to customize the behavior of any step, you can do so by defining a new type and defining a new method for the step you&#39;re changing, eg, introduce a new reranker:</p> <pre><code class="julia hljs">PromptingTools.Experimental.RAGTools: rerank

<span class=hljs-keyword >struct</span> MyReranker &lt;: AbstractReranker <span class=hljs-keyword >end</span>
rerank(::MyReranker, index, candidates) = ...</code></pre> <p>And then you would set the <code>retrive</code> step to use your custom <code>MyReranker</code> via <code>reranker</code> keyword argument, eg, <code>retrieve&#40;....; reranker &#61; MyReranker&#40;&#41;&#41;</code> &#40;or customize the top-level dispatching <code>AbstractRetriever</code> struct&#41;.</p> <h3 id=passing_keyword_arguments_to_customize_the_pipeline ><a href="#passing_keyword_arguments_to_customize_the_pipeline" class=header-anchor >Passing Keyword Arguments to Customize the Pipeline</a></h3> <p>When you need to adjust specific aspects of the RAG pipeline, keyword arguments &#40;kwargs&#41; allow for targeted modifications. This approach is especially useful for customizing individual components within the system.</p> <p>To pinpoint the right keyword arguments &#40;kwargs&#41; for customization:</p> <ul> <li><p><strong>Consult the Diagram</strong>: Review the RAG pipeline diagram or documentation. Identify the component you want to adjust.</p> <li><p><strong>Use the Format</strong>: Apply <code>&lt;dispatch_type&gt;</code> &#43; <code>_kwargs</code> for direct customizations. For nested adjustments, use prefixes that reflect the hierarchy &#40;e.g., <code>retriever_kwargs -&gt; rephraser_kwargs -&gt; template</code>&#41;.</p> </ul> <p>This approach allows for precise tweaks at any level of the pipeline, ensuring your modifications target exactly what you need.</p> <p>Practically, for a broad configuration, you might start with a <code>RAGConfig</code> instance, specifying components like the <code>AdvancedRetriever</code> to enhance retrieval capabilities. Preparing kwargs in advance facilitates managing the intricacies of nested configurations:</p> <pre><code class="julia hljs">cfg = RAGConfig(; retriever=AdvancedRetriever())

<span class=hljs-comment ># Organize kwargs for clarity and manageability</span>
kwargs = (
    retriever=AdvancedRetriever(),
    retriever_kwargs=(
        top_k=<span class=hljs-number >100</span>,
        top_n=<span class=hljs-number >5</span>,
        rephraser_kwargs=(
            template=:RAGQueryHyDE,
            model=<span class=hljs-string >&quot;custom-model&quot;</span>
        )
    ),
    generator_kwargs=(
        answerer_kwargs=(
            model=<span class=hljs-string >&quot;custom-answer-model&quot;</span>
        )
    ),
    api_kwargs=(
        url=<span class=hljs-string >&quot;http://localhost:8080&quot;</span>
    )
)

<span class=hljs-comment ># Execute with prepared arguments</span>
result = airag(cfg, index, question; kwargs...)</code></pre> <p>In scenarios where direct interaction with components like the retriever is needed, configure its kwargs similarly:</p> <pre><code class="julia hljs">retriever_kwargs = (
    top_k=<span class=hljs-number >100</span>,
    top_n=<span class=hljs-number >5</span>,
    rephraser_kwargs=(
        template=:RAGQueryHyDE,
        model=<span class=hljs-string >&quot;custom-model&quot;</span>
    ),
    api_kwargs=(
        url=<span class=hljs-string >&quot;http://localhost:8080&quot;</span>
    )
)

<span class=hljs-comment ># Apply to the retriever function directly</span>
result = retrieve(AdvancedRetriever(), index, question; retriever_kwargs...)</code></pre> <p>Delving deeper into the pipeline, for tasks such as rephrasing, specific kwargs can be directly applied to fine-tune the operation:</p> <pre><code class="julia hljs">rephrase_kwargs = (
    model=<span class=hljs-string >&quot;custom-model&quot;</span>,
    template=:RAGQueryHyDE,
    api_kwargs=(
        url=<span class=hljs-string >&quot;http://localhost:8080&quot;</span>
    )
)

<span class=hljs-comment ># Customize the rephrase step</span>
rephrased_query = rephrase(SimpleRephraser(), question; rephrase_kwargs...)</code></pre> <p>This structured approach to passing kwargs ensures that each stage of the RAG pipeline can be precisely controlled and customized, allowing for a tailored question-answering system that meets specific needs.</p> <h3 id=using_custom_indexes_or_vector_databases ><a href="#using_custom_indexes_or_vector_databases" class=header-anchor >Using Custom Indexes or Vector Databases</a></h3> <p><code>RAGTools</code> default implementation is built with an in-memory index suitable for datasets up to 100,000 chunks. For larger datasets or specific indexing needs:</p> <ul> <li><p><strong>Define a Custom Index</strong>: Create a new index by extending <code>AbstractChunkIndex</code>. Use the <code>ChunkIndex</code> as a guide for required fields.</p> <li><p><strong>Customize Interaction Methods</strong>: Implement new methods for your index to integrate with the retrieval process of the RAG pipeline.</p> <li><p><strong>Share Your Implementation</strong>: Contributions of integrations with common vector databases are welcome. They enrich the community&#39;s resources, enabling more versatile RAG applications.</p> </ul> <p>You would use the same approach to build a hybrid index &#40;semantic search &#43; BM25&#41;.</p> <p>This approach allows <code>RAGTools</code> to accommodate a broader range of applications, from large-scale datasets to specialized indexing strategies, enhancing its utility and adaptability.</p> <h2 id=conclusion ><a href="#conclusion" class=header-anchor >Conclusion</a></h2> <p>The latest enhancements in the <code>RAGTools</code> module are a leap forward in democratizing the development of RAG systems. By blending ease of use with deep customizability, we open new avenues for developers and researchers to explore AI-driven question-answering possibilities.</p> <h2 id=we_want_to_hear_from_you ><a href="#we_want_to_hear_from_you" class=header-anchor >We Want to Hear from You&#33;</a></h2> <p>Your feedback and use cases are crucial as we refine <code>RAGTools</code> and prepare to carve it out into its own package. Whether you&#39;re exploring the vanilla implementation or integrating vector databases, share your insights with us. Your contributions are key to enhancing this interface, making it more robust and versatile for the community. Help shape the future of <code>RAGTools</code>—join us in this exciting journey towards a more powerful and user-friendly generative AI toolkit.</p> <div class=page-foot > <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Jan Siml. Last modified: September 15, 2024. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. See the <a href="/privacy_policy/">Privacy Policy</a> </div> </div> </main> <script src="/libs/vela/metisMenu.min.js"></script> <script src="/libs/vela/slideout.min.js"></script> <script src="/libs/highlight/highlight.min.js"></script> <script>hljs.highlightAll();hljs.configure({tabReplace: ' '});</script>