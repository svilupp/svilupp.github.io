<!doctype html> <html lang=en > <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src= 'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f); })(window,document,'script','dataLayer','GTM-M28VNQP');</script> <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/styles/github.min.css"> <link href="/css/franklin.css" rel=stylesheet > <link href="/css/vela.css" rel=stylesheet > <script src="/libs/vela/jquery.min.js"></script> <link rel=icon  href="/assets/favicon.png"> <title>Jan's Scratchpad</title> <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-M28VNQP" height=0  width=0  style="display:none;visibility:hidden"></iframe></noscript> <div class="main-nav slideout-menu slideout-menu-left" id=menu > <div class=flex-container > <span class=sidebar-brand > <h3 style='font-size: 25px'>Scratchpad</h3> </span> </div> <nav class=sidebar-nav > <ul class=metismenu  id=metismenu  > <li><a href="/index.html">Home</a> <li><a href="/scratchpad/">Posts</a> <li><a href="/about/">About</a> <li><a href="/tag/">Tags</a> <li><a href="/privacy_policy/">Privacy Policy</a> <li><a href="/cookie_policy/">Cookie Policy</a> </ul> </nav> </div> <main id=panel  class="slidout-panel slideout-panel-left"> <div class="toggle-button hamburger hamburger--spin"> <div class=hamburger-box > <div class=hamburger-inner ></div> </div> </div> <h1 class="page title">AI-Assisted Coding: Why It Won't Make You 10x More Productive (Unless You Let It)</h1> <hr> <div class=franklin-content ><h2 id=tldr ><a href="#tldr" class=header-anchor >TL;DR</a></h2> <p>I&#39;ve been experimenting with AI-assisted coding tools, and I&#39;ve noticed something intriguing: these tools don&#39;t automatically boost productivity. My hypothesis is that to truly benefit, developers need to fundamentally change how they approach coding. It&#39;s not just about using the tools; it&#39;s about rethinking our entire development process.</p> <div class=franklin-toc ><ol><li><a href="#tldr">TL;DR</a><li><a href="#introduction">Introduction</a><li><a href="#the_productivity_paradox">The Productivity Paradox</a><li><a href="#the_productivity_ladder_from_1x_to_10x">The Productivity Ladder: From 1x to 10x</a><ol><li><a href="#basic_ai-assisted_coding_12x_-_14x"><ol> <li><p>Basic AI-assisted coding &#40;1.2x - 1.4x&#41;</p> </ol> </a><li><a href="#ol_start2_function-level_assistance_2x"><ol start=2 > <li><p>Function-level assistance &#40;2x&#41;</p> </ol> </a><li><a href="#ol_start3_contextual_code_generation_3x"><ol start=3 > <li><p>Contextual code generation &#40;3x&#41;</p> </ol> </a><li><a href="#ol_start4_high-level_functionality_requests_5x"><ol start=4 > <li><p>High-level functionality requests &#40;5x&#41;</p> </ol> </a><li><a href="#ol_start5_ai-first_development_approach_10x"><ol start=5 > <li><p>AI-first development approach &#40;10x&#41;</p> </ol> </a></ol><li><a href="#reengineering_your_coding_process">Reengineering Your Coding Process</a><li><a href="#measuring_progress_and_setting_expectations">Measuring Progress and Setting Expectations</a><li><a href="#conclusion">Conclusion</a></ol></div> <h2 id=introduction ><a href="#introduction" class=header-anchor >Introduction</a></h2> <p>For the past few months, I&#39;ve been grappling with a question that just won&#39;t leave my mind: Are AI-assisted coding tools really making us more productive? As I&#39;ve integrated tools like GitHub Copilot, Cursor, and various AI-powered code completion systems into my workflow, I&#39;ve noticed something surprising. Despite the hype, I wasn&#39;t seeing the massive productivity gains I&#39;d expected – at least, not at first.</p> <p>This observation led me down a rabbit hole of experimentation and discussion with fellow developers. What I&#39;ve found is both exciting and a bit unsettling. It&#39;s a hypothesis I&#39;m still testing, but I think it&#39;s worth sharing:</p> <p>AI-assisted coding tools, on their own, won&#39;t significantly boost your productivity. To reap their full benefits, you need to fundamentally change how you approach coding. Okay, except for smart text completions – those benefits come immediately.</p> <p>Now, I&#39;m not 100&#37; certain about this, but it&#39;s a pattern I&#39;ve observed repeatedly, both in my own work and in conversations with other developers. It reminds me of something I read about the electrification of factories in the early 20th century. Initially, factory owners simply replaced steam engines with electric motors, expecting miraculous efficiency gains. But the real revolution came when they completely redesigned their factories around electricity&#39;s unique advantages. That&#39;s when productivity truly soared.</p> <p>I think we might be at a similar inflection point with AI and coding. To really leverage these new tools, we might need to rethink our entire development process. Let me explain what I mean...</p> <h2 id=the_productivity_paradox ><a href="#the_productivity_paradox" class=header-anchor >The Productivity Paradox</a></h2> <p>Many developers fall into the trap of thinking that simply enabling an AI coding assistant will automatically make them more productive. They might see small gains – quicker autocomplete, fewer typos – but nothing revolutionary.</p> <p>The problem is that they&#39;re still coding the same way they always have, just with a fancier autocomplete. It&#39;s like using a smartphone only to make phone calls – you&#39;re missing out on its true potential.</p> <h2 id=the_productivity_ladder_from_1x_to_10x ><a href="#the_productivity_ladder_from_1x_to_10x" class=header-anchor >The Productivity Ladder: From 1x to 10x</a></h2> <p>Based on my experiences and discussions with fellow developers, I would like to propose a &quot;productivity ladder&quot; that shows how we can progressively leverage AI tools for greater efficiency. Let&#39;s climb it together:</p> <h3 id=basic_ai-assisted_coding_12x_-_14x ><a href="#basic_ai-assisted_coding_12x_-_14x" class=header-anchor ><ol> <li><p>Basic AI-assisted coding &#40;1.2x - 1.4x&#41;</p> </ol> </a></h3> <p>This is where most developers start. You&#39;ve enabled GitHub Copilot or a similar tool, and you&#39;re getting better code completions. It&#39;s nice, but it&#39;s not game-changing.</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> calculate_total(items)
    <span class=hljs-comment ># AI suggests the following line:</span>
    <span class=hljs-keyword >return</span> sum(item.price*item.quantity <span class=hljs-keyword >for</span> item <span class=hljs-keyword >in</span> items)
<span class=hljs-keyword >end</span></code></pre> <p>That&#39;s the &#43;20&#37; boost.</p> <p>If you&#39;re using Cursor, you might be seeing multi-line completions and TAB-jumps to navigate through them across your file. Also, it reads your edit history, so it tries to predict what you&#39;re going to do next.</p> <p>This would be the &#43;40&#37; boost, which comes for &quot;free&quot; &#40;it&#39;s worth paying for the premium version&#41;.</p> <h3 id=ol_start2_function-level_assistance_2x ><a href="#ol_start2_function-level_assistance_2x" class=header-anchor ><ol start=2 > <li><p>Function-level assistance &#40;2x&#41;</p> </ol> </a></h3> <p>Now you&#39;re starting to use the AI chat to generate entire functions. This is where many developers stop, thinking they&#39;ve mastered AI-assisted coding, while they copy&amp;paste the AI-generated code into their editor and back as they run into errors.</p> <p>Chat Prompt: &quot;Write a function to validate an email address&quot;</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> validate_email(email::<span class=hljs-built_in >String</span>)
    pattern = <span class=hljs-string >r&quot;^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}$&quot;</span>
    <span class=hljs-keyword >return</span> occursin(pattern, email)
<span class=hljs-keyword >end</span></code></pre> <h3 id=ol_start3_contextual_code_generation_3x ><a href="#ol_start3_contextual_code_generation_3x" class=header-anchor ><ol start=3 > <li><p>Contextual code generation &#40;3x&#41;</p> </ol> </a></h3> <p>Here&#39;s where things get interesting. You&#39;re not just asking for isolated functions; you&#39;re providing context from your codebase and asking the AI to generate code that fits seamlessly into your existing structure.</p> <p>Your press CMD&#43;K to generate code inside the script &#40;or perhaps highlight the necessary lines to change&#41;. Then you use <code>@</code> to link in any relevant functions to use as reference or examples. Prompt: &quot;Based on the function XYZ, connect to the database and pull the same data, except, retrieve all the rows without any aggregation&quot;</p> <p>This is good, it means you don&#39;t have to copy&amp;paste and have much less to change to make the function fit your needs and style. You simply click to accept the changes based on a diff, and you&#39;re done.</p> <h3 id=ol_start4_high-level_functionality_requests_5x ><a href="#ol_start4_high-level_functionality_requests_5x" class=header-anchor ><ol start=4 > <li><p>High-level functionality requests &#40;5x&#41;</p> </ol> </a></h3> <p>Now you&#39;re thinking at a higher level. Instead of asking for specific functions, you&#39;re describing functionality and letting the AI figure out the implementation details.</p> <p>Press CMD&#43;K and ask &quot;You have to a create a new structured extraction experiment that leverages aiextract. Prepare the prompt, extraction struct, the asyncmap loop with try-catch, capture the results and evaluate the experiment.&quot;</p> <p>For something like this, you must make sure there is a comparable example to work from &#40;either linked with <code>@</code> or in the same file&#41;.</p> <p>The big hack that I&#39;ve learned was to make it effortless to provide all this context. Did you that you can speak 2-3x faster than you can type? Learn to use speech-to-text software&#33; I can recommend <code>BetterDictation</code> for Mac. It will make your prompts easy to write and they will be more complete / comprehensive.</p> <p>Another hack is to refactor all your frequent rules and requirements into separate files saved in your project - think of them as SOP &#40;Standard Operating Procedure&#41; for your codebase. It makes it easier to link them in to your context and you won&#39;t have to repeat yourself in the prompt. </p> <p>Check out <code>cursorrules</code> for Cursor - you can find many examples in the <a href="https://cursor.directory/">cursor.directory</a>.</p> <p>I&#39;m also working on a tiny package to make it easier to create such &quot;cheatsheets&quot; for any project and repository, but we can talk about that another time.</p> <h3 id=ol_start5_ai-first_development_approach_10x ><a href="#ol_start5_ai-first_development_approach_10x" class=header-anchor ><ol start=5 > <li><p>AI-first development approach &#40;10x&#41;</p> </ol> </a></h3> <p>This is the holy grail, but it&#39;s not what you might expect. The key isn&#39;t just using AI as a tool; it&#39;s fundamentally rethinking your development process. Here&#39;s the counterintuitive part: you don&#39;t start with coding or even with AI prompts.</p> <ol> <li><p>Begin by clearly defining your end product and work backwards. This &quot;right-to-left&quot; thinking helps avoid unnecessary steps. This prevents the temptation to generate unnecessary code.</p> <li><p>Use AI strategically for rapid prototyping and iteration, but only after you have a clear plan. The real boost comes from skipping unnecessary code, not just coding faster.</p> <li><p>Focus your energy on truly creative aspects: problem-solving, architecture design, and user experience. Let AI handle more routine tasks.</p> <li><p>Master your tool&#39;s limits. Know when to make edits yourself, when to provide more context, and when to ask for high-level functionality. This mastery comes from daily refinement and careful observation.</p> <li><p>Adapting this approach to existing large codebases is challenging &#40;you often start from 1x&#33;&#41;. You&#39;ll need to carefully consider which productivity ladder steps to use for maximum benefit, often mixing approaches based on the specific task and codebase structure.</p> </ol> <p>Remember, the goal isn&#39;t to generate as much code as possible, but to create the most effective solution with the least unnecessary work. It&#39;s a delicate balance of leveraging AI capabilities while maintaining a clear vision of your end product.</p> <h2 id=reengineering_your_coding_process ><a href="#reengineering_your_coding_process" class=header-anchor >Reengineering Your Coding Process</a></h2> <p>To climb this ladder, you need to let go of old habits. It&#39;s uncomfortable at first – you might feel like you&#39;re losing control or that your coding skills will atrophy. But remember, your value as a developer isn&#39;t in writing boilerplate code; it&#39;s in your creativity, problem-solving skills, and ability to see the big picture.</p> <p>Here are some tips for each level:</p> <ol> <li><p><strong>Basic AI-assisted coding</strong>: Start small. Get comfortable with accepting AI suggestions for simple completions.</p> <li><p><strong>Function-level assistance</strong>: Learn to write clear, specific prompts. The better you communicate with the AI, the better its output.</p> <li><p><strong>Contextual code generation</strong>: Always provide relevant context from your codebase. This helps the AI match your coding style and conventions.</p> <li><p><strong>High-level functionality</strong>: Practice describing functionality in plain language. Think about what you want to achieve, not how to code it.</p> <li><p><strong>AI-first development</strong>: Start projects with high-level outlines. Use AI to rapidly prototype, then iterate and refine.</p> </ol> <h2 id=measuring_progress_and_setting_expectations ><a href="#measuring_progress_and_setting_expectations" class=header-anchor >Measuring Progress and Setting Expectations</a></h2> <p>As you climb the productivity ladder, it&#39;s crucial to track your progress. Time yourself on common tasks and see how you improve. For example, I know that creating a new experiment with a single prompt, loop, and basic checks takes me about 20-25 minutes from scratch, or 15 minutes if I have a similar example to work from.</p> <p>Be aware of potential pitfalls:</p> <ul> <li><p>Over-reliance on AI can lead to debugging nightmares if you don&#39;t understand the generated code. Always check the diffs before you accept them.</p> <li><p>AI suggestions aren&#39;t always correct or optimal. Always review and test the code &#40;creating tests is super easy with generative models – you just need to ask&#33;&#41;.</p> <li><p>The productivity gains aren&#39;t linear. You&#39;ll have breakthroughs and plateaus.</p> </ul> <h2 id=conclusion ><a href="#conclusion" class=header-anchor >Conclusion</a></h2> <p>AI coding tools are not magic wands that automatically make you a 10x developer. They&#39;re more like power tools – incredibly useful, but only in the hands of someone who knows how to wield them effectively.</p> <p>The future of coding isn&#39;t about AI replacing developers; it&#39;s about developers who can effectively collaborate with AI to solve complex problems faster and more creatively than ever before.</p> <div class=page-foot > <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Jan Siml. Last modified: September 15, 2024. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. See the <a href="/privacy_policy/">Privacy Policy</a> </div> </div> </main> <script src="/libs/vela/metisMenu.min.js"></script> <script src="/libs/vela/slideout.min.js"></script> <script src="/libs/highlight/highlight.min.js"></script> <script>hljs.highlightAll();hljs.configure({tabReplace: ' '});</script>