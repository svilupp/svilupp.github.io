<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/styles/github.min.css"> <!-- bootstrap@5.3.1 and bootstrap icon@1.10--> <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel=stylesheet  integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin=anonymous > <link rel=stylesheet  href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css"> <link rel=stylesheet  href="/css/style.css"> <link rel=stylesheet  href="https://cdn.jsdelivr.net/npm/@docsearch/css@3"> <link data-n-head=ssr  rel=stylesheet  href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900|Material+Icons"> <link rel=stylesheet  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha512-z3gLpd7yknf1YoNbCzqRKc4qyor8gaKU1qmn+CShxbuBusANI9QpRohGBreCFkKxLhei6S9CQXFEbbKuqLg0DA==" crossorigin=anonymous  referrerpolicy=no-referrer  /> <link rel=stylesheet  href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha512-NhSC1YmyruXifcj/KFRWoC561YpHpc5Jtzgvbuzx5VozKpWvQ+4nXhPdFgmx8xqexRcpAglTj9sIBWINXa8x5w==" crossorigin=anonymous  referrerpolicy=no-referrer  /> <!-- favicon generated through https://realfavicongenerator.net/--> <link rel=apple-touch-icon  sizes=180x180  href="/assets/icon/apple-touch-icon.png"> <link rel=icon  type="image/png" sizes=32x32  href="/assets/icon/favicon-32x32.png"> <link rel=icon  type="image/png" sizes=16x16  href="/assets/icon/favicon-16x16.png"> <link rel=manifest  href="/assets/icon/site.webmanifest"> <link rel=mask-icon  href="/assets/icon/safari-pinned-tab.svg" color="#5bbad5"> <meta name=msapplication-TileColor  content="#da532c"> <meta name=theme-color  content="#ffffff"> <link rel=stylesheet  href="/_css/custom.css"> <title>Beyond Blocking: RAG Patterns for Intelligent Data Matching</title> <!-- {{ispage /jan/index.html}} {{insert head_tailwind.html}} {{end}} {{ispage /index.html}} {{insert head_tailwind.html}} {{end}} {{ispage /jan/wip.html}} {{insert head_tailwind.html}} {{end}} {{ispage /jan/scratchpad/index.html}} {{insert head_tailwind.html}} {{end}} --> <header class=bootstrap-styles  data-bs-theme=dark > <nav class="navbar navbar-expand-md navbar-dark fixed-top bg-dark"> <div class=container > <a href="/" class="navbar-brand d-flex align-items-center"> <svg xmlns="http://www.w3.org/2000/svg" width=16  height=16  fill=currentColor  class="bi bi-journal-text me-2" viewBox="0 0 16 16"> <path d="M5 10.5a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 0 1h-2a.5.5 0 0 1-.5-.5zm0-2a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5zm0-2a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5zm0-2a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5z"/> <path d="M3 0h10a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2v-1h1v1a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v1H1V2a2 2 0 0 1 2-2z"/> <path d="M1 5v-.5a.5.5 0 0 1 1 0V5h.5a.5.5 0 0 1 0 1h-2a.5.5 0 0 1 0-1H1zm0 3v-.5a.5.5 0 0 1 1 0V8h.5a.5.5 0 0 1 0 1h-2a.5.5 0 0 1 0-1H1zm0 3v-.5a.5.5 0 0 1 1 0v.5h.5a.5.5 0 0 1 0 1h-2a.5.5 0 0 1 0-1H1z"/> </svg> <strong>siml.earth</strong> </a> <button class=navbar-toggler  type=button  data-bs-toggle=collapse  data-bs-target="#navbarCollapse" aria-controls=navbarCollapse  aria-expanded=false  aria-label="Toggle navigation"> <span class=navbar-toggler-icon ></span> </button> <div class="collapse navbar-collapse" id=navbarCollapse > <ul class="navbar-nav me-auto mb-2 mb-md-0"> <li class="nav-item dropdown"> <a class="nav-link dropdown-toggle fw-bold" href="#" id=navbarDropdown  role=button  data-bs-toggle=dropdown  aria-expanded=false > Sites </a> <ul class=dropdown-menu  aria-labelledby=navbarDropdown > <li><h6 class=dropdown-header >Choose a Site</h6> <li><a class=dropdown-item  href="/jan/">Jan's Site</a> <li><a class=dropdown-item  href="/ann/">Ann's Site</a> </ul> <li class=nav-item ><hr class="dropdown-divider mx-2"> <li class=nav-item > <span class="navbar-text px-2 fw-bold d-flex align-items-center">Jan's:</span> <li class=nav-item > <a class=nav-link  aria-current=page  href="/jan/">Home</a> <li class=nav-item > <a class=nav-link  href="/jan/scratchpad/">Posts</a> <li class=nav-item > <a class=nav-link  href="/jan/wip/">Work in Progress</a> <li class=nav-item > <a class=nav-link  href="/jan/about/">About</a> <li class=nav-item > <a class=nav-link  href="/jan/tags/">Tags</a> <li class=nav-item > <a class=nav-link  href="/jan/privacy_policy/">Privacy Policy</a> <li class=nav-item > <a class=nav-link  href="/jan/cookie_policy/">Cookie Policy</a> </ul> </div> </div> </nav> </header> <div class="container py-3 px-3 mx-auto"> <div class=franklin-content ><h1 id=tldr ><a href="#tldr" class=header-anchor >TL;DR</a></h1> <p>RAG isn&#39;t just for chatbots—we demonstrate how to repurpose RAG patterns for intelligent data matching in Julia. By combining semantic search with LLM-powered analysis, we create a robust deduplication system that handles real-world data variations while providing transparent, explainable decisions.</p> <div class=franklin-toc ><ol><li><a href="#tldr">TL;DR</a><li><a href="#beyond_blocking_rag_patterns_for_intelligent_data_matching">Beyond Blocking: RAG Patterns for Intelligent Data Matching</a><ol><li><a href="#the_rag_parallel">The RAG Parallel</a><li><a href="#why_this_matters">Why This Matters</a><li><a href="#the_implementation">The Implementation</a><li><a href="#getting_started">Getting Started</a><li><a href="#conclusion">Conclusion</a><li><a href="#code_implementation">Code Implementation</a><li><a href="#advanced_section">Advanced Section</a></ol></ol></div> <h1 id=beyond_blocking_rag_patterns_for_intelligent_data_matching ><a href="#beyond_blocking_rag_patterns_for_intelligent_data_matching" class=header-anchor >Beyond Blocking: RAG Patterns for Intelligent Data Matching</a></h1> <p>Traditional deduplication approaches rely on exact matching or complex rule sets &#40;blocking&#41;. But what if we thought about deduplication the same way we think about RAG in large language models?</p> <h2 id=the_rag_parallel ><a href="#the_rag_parallel" class=header-anchor >The RAG Parallel</a></h2> <p>In traditional RAG:</p> <ol> <li><p><strong>Retrieve</strong>: Find relevant context from a knowledge base</p> <li><p><strong>Generate</strong>: Use an LLM to reason about that context and generate an answer</p> </ol> <p>In RAG-based deduplication:</p> <ol> <li><p><strong>Retrieve</strong>: Find potential matching records using semantic search</p> <li><p><strong>Reason</strong>: Use an LLM-as-a-judge to analyze whether candidates truly match</p> </ol> <p>This parallel isn&#39;t just theoretical—it leads to a more robust and maintainable solution &#40;and it scales well too&#33;&#41;</p> <h2 id=why_this_matters ><a href="#why_this_matters" class=header-anchor >Why This Matters</a></h2> <p>Real-world customer data is messy. Names appear as &quot;Bob&quot; or &quot;Robert&quot;. Addresses contain typos. Phone numbers use different formats. Traditional rule-based systems struggle with these variations, requiring constant maintenance and producing brittle solutions.</p> <p>RAG-based deduplication handles these challenges naturally. The semantic search finds potential matches despite surface differences, while the LLM applies human-like reasoning to determine true matches. Each decision comes with detailed explanation, making the process transparent and auditable &#40;and acts as a source for future improvements&#41;.</p> <p>In addition, you can plug use the same tricks to improve your system as you would for RAG in LLMs, eg, rephrase queries &#40;&#61;bring data format/shape closer to your DB&#41;, re-rank results &#40;&#61;light LLM as a judge or classic scoring to weed out poor hits&#41;, etc.</p> <h2 id=the_implementation ><a href="#the_implementation" class=header-anchor >The Implementation</a></h2> <p>Our Julia solution combines a hybrid search index for candidate retrieval with LLM-powered analysis. The system processes high-confidence matches automatically while flagging edge cases for human review. All processing happens locally, preserving data privacy.</p> <img src="/assets/rag_dedupe/diagram.jpeg" width=500  alt="RAG-Enhanced Matching"> <p>The diagram above illustrates how our system processes new contact records:</p> <ol> <li><p>A new contact enters the system</p> <li><p>The hybrid search index &#40;combining semantic and keyword search&#41; identifies potential matches</p> <li><p>The LLM-as-a-judge analyzes each candidate pair, providing detailed reasoning</p> <li><p>High-confidence matches are processed automatically, while uncertain cases are flagged for review</p> </ol> <h2 id=getting_started ><a href="#getting_started" class=header-anchor >Getting Started</a></h2> <p>You can see the complete implementation in the code section below.</p> <p>I also illustrate some basic optimizations like re-ranking and re-phrasing.</p> <h2 id=conclusion ><a href="#conclusion" class=header-anchor >Conclusion</a></h2> <p>RAG-based data matching represents a paradigm shift in how we approach data matching. By leveraging the same patterns that make RAG successful in LLMs, we can create more intelligent entity resolution systems. The approach reduces manual review time while providing transparent, explainable decisions.</p> <p>The complete implementation is available in the code section below for those interested in the technical details.</p> <h2 id=code_implementation ><a href="#code_implementation" class=header-anchor >Code Implementation</a></h2> <p>Note: The prompts are not optimized at all. I kept them simple to make them easier to understand – you need to customize them to YOUR DATA.</p> <p>Shared utilities from the data generation &#40;see previous blog post&#41;.</p> <p>File: <code>types_and_utils.jl</code></p> <pre><code class="julia hljs"><span class=hljs-comment >## Key types</span>
Base.<span class=hljs-meta >@kwdef</span> <span class=hljs-keyword >struct</span> ContactInfo
    full_name::<span class=hljs-built_in >String</span>
    address::<span class=hljs-built_in >String</span>
    city::<span class=hljs-built_in >String</span>
    state::<span class=hljs-built_in >String</span> = <span class=hljs-string >&quot;NY&quot;</span>
    email::<span class=hljs-built_in >String</span>
    phone::<span class=hljs-built_in >String</span>
<span class=hljs-keyword >end</span>

<span class=hljs-meta >@enum</span> JudgementType DUPLICATE NOTDUPLICATE
<span class=hljs-meta >@enum</span> Difficulty EASY MEDIUM HARD
Base.<span class=hljs-meta >@kwdef</span> <span class=hljs-keyword >struct</span> ContactVariation
    reasoning::<span class=hljs-built_in >String</span>
    type::JudgementType
    difficulty::Difficulty
    full_name::<span class=hljs-built_in >String</span>
    address::<span class=hljs-built_in >String</span>
    city::<span class=hljs-built_in >String</span>
    state::<span class=hljs-built_in >String</span> = <span class=hljs-string >&quot;NY&quot;</span>
    email::<span class=hljs-built_in >String</span>
    phone::<span class=hljs-built_in >String</span>
<span class=hljs-keyword >end</span>


Base.show(io::<span class=hljs-built_in >IO</span>, contact::<span class=hljs-built_in >Union</span>{ContactInfo,ContactVariation}) = dump(io, contact; maxdepth=<span class=hljs-number >1</span>)


<span class=hljs-comment >## Utility functions</span>
<span class=hljs-string >&quot;Converts a ContactInfo or ContactVariation to a string to pass to a LLM&quot;</span>
<span class=hljs-keyword >function</span> format_contact(contact)
    <span class=hljs-string >&quot;Contact: <span class=hljs-subst >$(contact.full_name)</span>\nAddress: <span class=hljs-subst >$(contact.address)</span>\nCity: <span class=hljs-subst >$(contact.city)</span>\nState: <span class=hljs-subst >$(contact.state)</span>\nEmail: <span class=hljs-subst >$(contact.email)</span>\nPhone: <span class=hljs-subst >$(contact.phone)</span>&quot;</span>
<span class=hljs-keyword >end</span></code></pre> <p>Let&#39;s load the generated data and build the index.</p> <p>File: <code>build_index.jl</code></p> <pre><code class="julia hljs"><span class=hljs-comment ># Index building functionality</span>
<span class=hljs-keyword >using</span> PromptingTools
<span class=hljs-keyword >const</span> PT = PromptingTools
<span class=hljs-keyword >using</span> PromptingTools.Experimental.RAGTools
<span class=hljs-keyword >const</span> RT = PromptingTools.Experimental.RAGTools
<span class=hljs-keyword >using</span> JSON3
<span class=hljs-keyword >using</span> Serialization
<span class=hljs-keyword >using</span> LinearAlgebra, Unicode, SparseArrays, Snowball

<span class=hljs-comment ># Load the contacts</span>
contacts_data = JSON3.read(<span class=hljs-string >&quot;rag_dedupe/contacts.json&quot;</span>, <span class=hljs-built_in >Vector</span>{ContactInfo})

<span class=hljs-comment ># Convert contacts to strings for indexing</span>
documents = [format_contact(contact) <span class=hljs-keyword >for</span> contact <span class=hljs-keyword >in</span> contacts_data]
sources = collect(<span class=hljs-number >1</span>:length(documents)) .|&gt; string

index = RT.build_index(
    documents; chunker_kwargs=(; sources)
)

<span class=hljs-comment ># Serialize the index</span>
serialize(<span class=hljs-string >&quot;rag_dedupe/contacts_index.jls&quot;</span>, index)
keywords_index = RT.ChunkKeywordsIndex(index)
multi_index = RT.MultiIndex([index, keywords_index])
serialize(<span class=hljs-string >&quot;rag_dedupe/contacts_multi_index.jls&quot;</span>, multi_index)</code></pre> <p>And finally, let&#39;s set up our contact matching system.</p> <p>File: <code>search_contacts.jl</code></p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> PromptingTools
<span class=hljs-keyword >const</span> PT = PromptingTools
<span class=hljs-keyword >using</span> PromptingTools.Experimental.RAGTools
<span class=hljs-keyword >const</span> RT = PromptingTools.Experimental.RAGTools
<span class=hljs-keyword >using</span> JSON3
<span class=hljs-keyword >using</span> Serialization
<span class=hljs-keyword >using</span> LinearAlgebra, Unicode, SparseArrays, Snowball

<span class=hljs-comment ># Load the serialized index</span>
index = deserialize(<span class=hljs-string >&quot;rag_dedupe/contacts_multi_index.jls&quot;</span>)

<span class=hljs-meta >@enum</span> ConfidenceType LOW_CONFIDENCE MEDIUM_CONFIDENCE HIGH_CONFIDENCE
<span class=hljs-string >&quot;Decision whether the candidate contact is a duplicate of the original contact. First, provide thorough reasoning, then the judgement. Make sure to weigh all evidence in favor of being DUPLICATE and against it.&quot;</span>
<span class=hljs-keyword >struct</span> DuplicateJudgement
    reasoning::<span class=hljs-built_in >String</span>
    confidence::ConfidenceType
    judgement::JudgementType
<span class=hljs-keyword >end</span>
<span class=hljs-meta >@kwdef</span> <span class=hljs-keyword >struct</span> MatchResult
    reasoning::<span class=hljs-built_in >String</span>
    confidence::ConfidenceType
    judgement::JudgementType
    candidate::<span class=hljs-built_in >String</span>
    match::<span class=hljs-built_in >String</span>
    source::<span class=hljs-built_in >String</span>
<span class=hljs-keyword >end</span>
<span class=hljs-comment >## Let&#x27;s define a pretty printer</span>
Base.show(io::<span class=hljs-built_in >IO</span>, contact::<span class=hljs-built_in >Union</span>{ContactInfo,ContactVariation}) = dump(io, contact; maxdepth=<span class=hljs-number >1</span>)

<span class=hljs-comment ># Create custom templates for duplicate detection</span>
template = PT.create_template(;
    system=<span class=hljs-string >&quot;&quot;&quot;Your task is to determine if two contact entries refer to the same person.
    Consider variations in names (nicknames, titles, suffixes), formatting differences in phone/email, and typos.
    If a detail or field is missing, assume it could be anything. The more missing details, the less confident you should be.
    Provide detailed reasoning for your decision.&quot;&quot;&quot;</span>,
    user=<span class=hljs-string >&quot;&quot;&quot;Compare these contacts and determine if they are duplicates:
    Original Contact:\n---\n{{original}}\n---\n\n
    Candidate Contact:\n---\n{{candidate}}\n---\n\n
    Explain your reasoning and conclude with DUPLICATE or NOT_DUPLICATE.&quot;&quot;&quot;</span>,
    load_as=:DuplicateDetector
)


<span class=hljs-string >&quot;Vanilla search, no rephrasing and no re-ranking.&quot;</span>
<span class=hljs-keyword >function</span> find_duplicates(index, contact; n_results=<span class=hljs-number >5</span>)

    contact_blob = format_contact(contact)
    <span class=hljs-comment ># Use basic retriever</span>
    retriever = RAGTools.SimpleRetriever()
    retriever.processor = RT.KeywordsProcessor()
    retriever.finder = RT.MultiFinder([RT.CosineSimilarity(), RT.BM25Similarity()])

    <span class=hljs-comment ># Perform search</span>
    results = RAGTools.retrieve(
        retriever,
        index,
        contact_blob;
        top_k=n_results
    )

    <span class=hljs-comment ># Analyze each candidate</span>
    judgements = []
    asyncmap(eachindex(results.context)) <span class=hljs-keyword >do</span> i
        content, source = results.context[i], results.sources[i]
        <span class=hljs-comment >## TODO: skip if match score is low</span>
        <span class=hljs-comment >## TODO: skip the same record from a duplicate index, eg, look for source and if we have checked it already! Ideally, tackled in custom reranker</span>
        msg = aiextract(
            :DuplicateDetector;
            original=contact_blob,
            candidate=content,
            return_type=DuplicateJudgement
        )
        <span class=hljs-comment ># Skip if extraction failed</span>
        <span class=hljs-keyword >if</span> !(msg.content <span class=hljs-keyword >isa</span> <span class=hljs-built_in >Dict</span>)
            <span class=hljs-comment >## Save the `source` of the matched record for actually matching to your database</span>
            res = MatchResult(; [f =&gt; getfield(msg.content, f) <span class=hljs-keyword >for</span> f <span class=hljs-keyword >in</span> propertynames(msg.content)]..., source, candidate=contact_blob, match=content)
            push!(judgements, res)
        <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >end</span>

    <span class=hljs-keyword >return</span> judgements
<span class=hljs-keyword >end</span>

<span class=hljs-comment ># Load test variations to verify</span>
contacts = JSON3.read(<span class=hljs-string >&quot;rag_dedupe/contacts.json&quot;</span>, <span class=hljs-built_in >Vector</span>{ContactInfo})
original_contact = contacts[<span class=hljs-number >1</span>]  <span class=hljs-comment ># Original contact</span>
variations = JSON3.read(<span class=hljs-string >&quot;rag_dedupe/contact_variations.json&quot;</span>, <span class=hljs-built_in >Vector</span>{ContactVariation})
known_duplicate = variations[<span class=hljs-number >2</span>]   <span class=hljs-comment ># Known duplicate with typos</span>
known_non_duplicate = variations[<span class=hljs-number >12</span>]  <span class=hljs-comment ># Similar but different contact</span>

judgements = find_duplicates(index, original_contact)
judgements[<span class=hljs-number >1</span>]

judgements = find_duplicates(index, known_duplicate)
judgements[<span class=hljs-number >1</span>]

judgements = find_duplicates(index, known_non_duplicate)
judgements[<span class=hljs-number >1</span>]

<span class=hljs-comment ># What now? Well, you are basically producing judgements for any potential candidate</span>
<span class=hljs-comment ># Check fields: reasoning, confidence, judgement (the other fields are added purely for your convenience)</span></code></pre> <h2 id=advanced_section ><a href="#advanced_section" class=header-anchor >Advanced Section</a></h2> <p>The chances are the above will not be good enough for your use case. You can do the following:</p> <ul> <li><p>generated more labeled data and load some of it into the index to have some hard comparisons</p> <li><p>build your EVALS &#40;&#61; have a number for &quot;success rate&quot; for each version of your system&#41;</p> <li><p>improve the prompts</p> <li><p>try BM25 vs cosine similarity only</p> <li><p>add re-ranking &#40;naively dedupe, filter by the minimal acceptable BM25 and cosine scores for your data&#41;</p> <li><p>add re-phrasing &#40;use when moving from less detail -&gt; more detail, eg, customers gives only email but you need to match to full data record&#41;</p> </ul> <p>And iterate...</p> <p>I&#39;ve included examples of the above optimizations below.</p> <pre><code class="julia hljs"><span class=hljs-comment ># You can define a simple custom reranker, eg, just dedupe sources, check the match scores, etc.</span>
<span class=hljs-comment ># Custom reranker -- eg, for dedupe etc</span>
<span class=hljs-comment ># struct MyReranker &lt;: RT.AbstractReranker end</span>
<span class=hljs-comment ># RT.rerank(::MyReranker, index, candidates)</span>

<span class=hljs-comment >## This will be quite poor, because RankGPT has a prompt to look for question/answer pairs -- just tweak it. </span>
<span class=hljs-comment ># Template is `:RAGRankGPT` (view it with `aitemplates(:RAGRankGPT)`).</span>

<span class=hljs-string >&quot;Search with re-ranking.&quot;</span>
<span class=hljs-keyword >function</span> find_duplicates_reranked(index, contact; n_results=<span class=hljs-number >5</span>)

    contact_blob = format_contact(contact)
    <span class=hljs-comment ># Use reranked retriever</span>
    retriever = RAGTools.SimpleRetriever()
    retriever.processor = RT.KeywordsProcessor()
    retriever.finder = RT.MultiFinder([RT.CosineSimilarity(), RT.BM25Similarity()])
    retriever.reranker = RT.RankGPTReranker()

    <span class=hljs-comment ># Perform search</span>
    results = RAGTools.retrieve(
        retriever,
        index,
        contact_blob;
        top_k=n_results
    )

    <span class=hljs-comment ># Analyze each candidate</span>
    judgements = []
    asyncmap(eachindex(results.context)) <span class=hljs-keyword >do</span> i
        content, source = results.context[i], results.sources[i]
        <span class=hljs-comment >## TODO: skip if match score is low</span>
        <span class=hljs-comment >## TODO: skip the same record from a duplicate index, eg, look for source and if we have checked it already! Ideally, tackled in custom reranker</span>
        msg = aiextract(
            :DuplicateDetector;
            original=contact_blob,
            candidate=content,
            return_type=DuplicateJudgement
        )
        <span class=hljs-comment ># Skip if extraction failed</span>
        <span class=hljs-keyword >if</span> !(msg.content <span class=hljs-keyword >isa</span> <span class=hljs-built_in >Dict</span>)
            <span class=hljs-comment >## Save the `source` of the matched record for actually matching to your database</span>
            res = MatchResult(; [f =&gt; getfield(msg.content, f) <span class=hljs-keyword >for</span> f <span class=hljs-keyword >in</span> propertynames(msg.content)]..., source, candidate=contact_blob, match=content)
            push!(judgements, res)
        <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >end</span>

    <span class=hljs-keyword >return</span> judgements
<span class=hljs-keyword >end</span>

judgements = find_duplicates_reranked(index, original_contact)
judgements[<span class=hljs-number >1</span>]

judgements = find_duplicates_reranked(index, known_duplicate)
judgements[<span class=hljs-number >1</span>]

judgements = find_duplicates_reranked(index, known_non_duplicate)
judgements[<span class=hljs-number >1</span>]</code></pre> <p>Search with partial details: Quite often you get partial details, eg, only an email address and name or email and phone numbers. You can define a custom rephraser to generate several useful search terms, eg, leaving some specific fields that seems wrong out OR generating possible names if all you have is a yahoo email or sth like that.</p> <pre><code class="julia hljs"><span class=hljs-comment ># Use `SimpleRephraser` and provide your prompt template if you want just 1 rephrased query.</span>
<span class=hljs-comment ># </span>
<span class=hljs-comment >## Example template for email to name</span>

<span class=hljs-meta >@kwdef</span> <span class=hljs-keyword >struct</span> ContactPartials
    email::<span class=hljs-built_in >String</span>
    full_name::<span class=hljs-built_in >String</span>
<span class=hljs-keyword >end</span>
<span class=hljs-keyword >function</span> format_contact(partials::ContactPartials)
    <span class=hljs-string >&quot;Email: <span class=hljs-subst >$(partials.email)</span>\nPlausible Name: <span class=hljs-subst >$(partials.full_name)</span>&quot;</span>
<span class=hljs-keyword >end</span>
PT.create_template(;
    system=<span class=hljs-string >&quot;&quot;&quot;
    You will be provided with an email address and should generate 3-5 plausible contact details based on common email patterns.
    For example:
    - john.smith@company.com -&gt; John Smith
    - jsmith123@email.com -&gt; J Smith, John Smith, James Smith, ...
    - dr.jane.doe.md@hospital.org -&gt; Dr. Jane Doe MD, Jane Doe

    If there are abbreviations, generate some names with the same abbreviation and some expanded.
    Generate with and without titles.

    Return only the most likely names, formatted appropriately with proper capitalization.
    If there is no ambiguity, generate just the one record.&quot;&quot;&quot;</span>,
    user=<span class=hljs-string >&quot;&quot;&quot;Given this email address: {{query}}

    Extract the most likely variants of their full name.&quot;&quot;&quot;</span>,
    load_as=:GenerateContactDetails)

<span class=hljs-keyword >struct</span> EmailRephraser &lt;: RT.AbstractRephraser <span class=hljs-keyword >end</span>

<span class=hljs-keyword >function</span> RT.rephrase(rephraser::EmailRephraser, question::<span class=hljs-built_in >AbstractString</span>;
    verbose::<span class=hljs-built_in >Bool</span>=<span class=hljs-literal >true</span>, model::<span class=hljs-built_in >String</span>=PT.MODEL_CHAT, template::<span class=hljs-built_in >Symbol</span>=:GenerateContactDetails, kwargs...)
    <span class=hljs-comment >## checks</span>
    placeholders = only(aitemplates(template)).variables <span class=hljs-comment ># only one template should be found</span>
    <span class=hljs-meta >@assert</span> (:query <span class=hljs-keyword >in</span> placeholders) <span class=hljs-string >&quot;Provided RAG Template <span class=hljs-subst >$(template)</span> is not suitable. It must have a placeholder: `query`.&quot;</span>

    msg = aiextract(template; query=question, verbose, model, strict=<span class=hljs-literal >true</span>, json_mode=<span class=hljs-literal >true</span>, return_type=PT.ItemsExtract{ContactPartials}, kwargs...)
    <span class=hljs-keyword >return</span> [format_contact(c) <span class=hljs-keyword >for</span> c <span class=hljs-keyword >in</span> msg.content.items]
<span class=hljs-keyword >end</span>

<span class=hljs-comment >## Keep as is</span>
RT.rephrase(EmailRephraser(), <span class=hljs-string >&quot;jan.hrudka@company.com&quot;</span>)
RT.rephrase(EmailRephraser(), <span class=hljs-string >&quot;behappy23@gmail.com&quot;</span>)

<span class=hljs-comment >## Expands</span>
RT.rephrase(EmailRephraser(), <span class=hljs-string >&quot;prof.robert.smith.phd@university.edu&quot;</span>)
RT.rephrase(EmailRephraser(), <span class=hljs-string >&quot;mike.d.smith@google.com&quot;</span>)


<span class=hljs-comment ># The rest is the same as above, you just set `retriever.rephraser = PartialDetailsRephraser()`</span>
<span class=hljs-comment ># Obviously it would require your reranked and judge to be aligned for this partial matching task!</span></code></pre> <p>Hope you found this useful&#33;</p> <div class=page-foot > <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Jan Siml. Last modified: November 27, 2024. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div></div> <footer class=container > <p class=float-end ><a href="#">Back to top</a></p> <div class=footer-icons > <ul class=social-icons > <li><strong>Follow:</strong> <li><a href="https://github.com/svilupp" rel="nofollow noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width=16  height=16  fill=currentColor  class="bi bi-github" viewBox="0 0 16 16"> <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"/> </svg> GitHub</a> </ul> </div> <p class=copyright >&copy; 2023- Company, Inc. · <a href="#">Privacy</a> · <a href="#">Terms</a></p> </footer> <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.bundle.min.js" integrity=sha384-HwwvtgBNo3bZJJLYd8oVXjrBZt8cqVSpeBNS5n7C8IVInixGAoxmnlMuBnhbgrkm  crossorigin=anonymous ></script> <script src="/libs/highlight/highlight.min.js"></script> <script>hljs.highlightAll();hljs.configure({tabReplace: ' '});</script> <script src="https://cdn.jsdelivr.net/npm/@docsearch/js@3"></script>